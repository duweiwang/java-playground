### 5.1 引言
随着 Java 不断的发展，在对类文件格式上也是不断补充新元素。比如 Java 9 引入的模块化（module）的概念，Java 类型的注释、Lambda 语法 等等。
到 ASM3.X 时，每次 Java 新增的变化都会导致 ASM API 向后兼容，非常不友好。到 ASM4.0 时，引入了一种新机制用于确保后面的版本到
ASM4 都是后向兼容的。即为某个特定的 ASM 版本编写的类解析器，可在未来任何版本中使用。但是这些不仅仅靠 ASM 进行约束，还需要开发者遵守一些
简单的规则。
> ASM 4.0 中引入的后向兼容机制要求将 ClassVisitor 、 FieldVisitor 、MethodVisitor 等由接口变为抽象类，具有一个以 ASM 版本为参数的构造器。

由此引入的后向兼容约定如下：
- 如果本地集成使用 ASM 的版本为 x，那么本地编写代码时不能指定 ASM 版本大于 x，比如如果在 ClassReader.accept() 中指定了大于 x 的类作为输出，会失败报错
- 如果本地集成使用 ASM 的版本为 x 编写的代码，对于未来任意大于 x 的 ASM 版本，该代码都可以不加修改的正常运行
- 使用 ASM 的版本 x 编写的代码，当输入类的声明版本为 y 时，但只使用了 x 或以前版本的功能，则该代码可以在 y 版本或未来任何版本运行
- 对于为 ASM X 编写的代码，如果使用了大于 x 版本号的功能，则改代码必然失败
> 注意：最后三点与类生成器(ClassWriter) 无关

### 5.2 规则
规则 1：
要为 ASM X 编写一个 ClassVisitor 子类，就以这个版本号为参数，调用 ClassVisitor 构造器，在这个版本的 ClassVisitor 类中，绝对不要重写或调用弃用的方
法（或者将在之后版本引入的方法）。

规则 2：
不要使用访问器的继承，而要使用委托（即访问器链）。一种好的做法是让你的访问器类在默认情况为 final 的，以确保这一特性。